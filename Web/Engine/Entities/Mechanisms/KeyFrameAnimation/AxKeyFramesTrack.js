/**
 * Creates a new keyframes track object
 * Represents a collection of keyframes of the same type, and can produce the transformation, generated by these keyframes in a specified time
 * @constructor
 */
function AxKeyFramesTrack()
{
    AxList.call(this);
}

AxKeyFramesTrack.prototype = Object.create(AxList.prototype);



AxKeyFramesTrack.prototype.Dispose = function()
{
    for (var i = 0; i < this.count; i++)
        this.Set(i, null);
};

/**
 * Calculates the transform, produced by the keyframes at the specified time.
 * @param {AxMatrix} result The resulting transform, produced by the keyframes at the given time
 * @param {Number} time The time for which to get transform for
 */
AxKeyFramesTrack.prototype.GetTransform = function(result, time)
{
    var count = this.count;

    // No keyframes
    if (count === 0)
    {
        AxMatrix.CreateIdentity(result);
        return AxClassId.None;
    }

    // Only one keyframe
    else if (count === 1)
    {
        this.Get(0).Process(result);
        return this.Get(0).typeId;
    }

    // Time outside of left boundary
    else if (time <= this.Get(0).time)
    {
        this.Get(0).Process(result);
        return this.Get(0).typeId;
    }

    // Time outside of right boundary
    else if (time >= this.Get(count - 1).time)
    {
        this.Get(count - 1).Process(result);
        return this.Get(count - 1).typeId;
    }

    // Search - a minimum of 2 key frames are required
    else
    {
        var left = 0;
        var right = count - 2;

        var index = 0;
        var startTime, endTime;

        do
        {
            index = left + AxMath.Floor((right - left) / 2);
            startTime = this.Get(index).time;
            endTime = this.Get(index + 1).time;

            if (time > endTime)
                left = index + 1;
            else if (time < startTime)
                right = index - 1;
            else
                break;
        }
        while (left <= right);

        var blend = (time - startTime) / (endTime - startTime);

        this.Get(index).Process_2(result, this.Get(index + 1), blend);

        return this.Get(index).typeId;
    }
};